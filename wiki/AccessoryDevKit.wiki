<font size="5">
*Beaglebone based - Android Accessory Development Kit*
</font>
<br>
<br>
<font size="4">
*User Guide*
</font>
<br>
<br>
<font size="3">
*Contents*
*________*
</font>
<wiki:toc max_depth="2" />
= Introduction  =
The Android platform (from 3.1 onwards) has integrated a specific protocol "Android Open Accessory", which allows external embedded hardware (accessory) to interact with an Android-powered device (Android phone or tablet) in a special accessory mode over USB or Bluetooth interface. Android accessories are specifically designed to attach to Android-powered devices over USB or Bluetooth and adhere to a simple protocol (Android accessory protocol) that allows them to detect Android-powered devices that support accessory mode.

With majority of smart phones and tablets using Android today, an Android open accessory standard provides a vital link between phones, tablets and other Android powered devices and embedded systems which are pervasive in our daily life.

Android accessories can be audio docking stations, exercise machines, personal medical testing devices, weather stations, wearable gadgets or any other external hardware device that adds to the functionality of Android.

As of today, all the available Android accessory kits are based on micro controllers operating at very low MHz (max 150MHz) and limited peripheral set. For the first time, we provide an accessory kit based on TI's AM335x (ARM Cortex A8) application processor. The processor can operate at range of frequencies (100 MHz to 1 GHz), ultra-low power, very broad list of on chip peripherals and more over the system cost is comparable to that of an micro controller. More details about TI's AM335x can be found here www.ti.com/sitara.

Do we really need an application processor for an accessory ? Yes, the embedded products like home appliance, auto infotainment, personal health care, wearable gadgets, etc. are interacting with phones & tablets - they need an application processor to meet the required processing & peripheral set.

With the help of rowboat team, we were able to port Android accessory protocol for TI's AM335x based beaglebone platform. Beaglebone + capes based Android accessory kit gives developers the freedom to innovate and develop all new range of accessories for Android devices. It provides an easy to use software development kit, user/developer guide and pre-built examples. 

== Fundamentals of Beaglebone as Android Accessory ==

Beaglebone runs the Android accessory protocol (generic) and accessory application specific software. We use the TI's Starterware for Beaglebone as the base software and have developed & integrated the android accessory protocol and a sample application. We have also developed a dummy app (apk) for Android that runs on phone or tablet that interacts with Beaglebone application to control the peripherals on Beaglebone.

Functionally, Beaglebone is connected to Android powered (phone / tablet) device over USB, the Beaglebone operates USB in host mode (powers the bus and enumerates devices) and the Android-powered device acts as the USB device. Beaglebone runs the Android USB accessory protocol with application software, detects & enumerates the Android-powered device (phone/tablet) and starts the sample application (beaglebone side) that waits for commands from Android device (running sample accessory apk) to control/monitor the Beaglebone peripherals.

<br>
http://rowboat.googlecode.com/files/BB_Android_Accessory.png
<br>
Why use TI's StarterWare software package as a base software v/s Linux or u-boot ?
<br>
   - For Linux, we have to develop a all new USB class for Android accessory and a custom application that talks to peripheral Linux drivers. The implementation is not complex, we have plans to develop this in future.

   - u-boot has limited support for AM335x peripherals and we found USB Host protocol lack few features to implement the accessory protocol.

TI's starterware is free to use and distribute, comes with pre-integrated libraries with APIs to access every peripheral on AM335x processor, very easy to use with lots of examples, direct support from TI. For more details please refer to [http://processors.wiki.ti.com/index.php/StarterWare_Getting_Started_02.00.XX.XX StarterWare getting started guide] and [http://processors.wiki.ti.com/index.php/StarterWare_02.00.00.07_User_Guide user guide]<br>

=Out of Box Demo=

This section gives the instructions to quickly prepare an SD Card with pre-built binaries of beaglebone accessory software  and to experience Beaglebone as Android accessory.

==Getting Pre-built Images==

To successfully experience beaglebone as an Android accessory we need 
   * Beaglebone Starterware binary (with integrated Android accessory protocol and Accessory application) - BeagleBoneAcc.tar.gz
   * A sample Android application (.apk) to be installed on any Android phone or Tablet. - [http://rowboat.googlecode.com/files/TI-ADKDemo.tar.gz TI-ADKDemo.tar.gz]

<br>

== Prepartion of SD card  ==

Connect a Micro SD card via a USB card reader on an Ubuntu Machine<br>From a command terminal, type the below commands, 

{{{
   #> tar -xzvf BeagleBoneAcc.tar.gz
   #> cd BeagleBoneAcc
   #> sudo ./mkmmc-acc.sh /dev/sd<device>
}}}
The above step prepares the bootable SD Card with Starterware image, which can be used to boot beaglebone as an Android accessory.

==Install Accessory Application==

Follow the below steps to install the example Android application on Android phone or tablet (version 4.0.3 or above)

   * The apk is located in TI-ADKDemo/bin/TI-ADKDemo.apk
   * Install this application on Android4.0.3 powered device.
   * The phone can be connected to a Windows or Linux PC and the application can be transferred/installed through ADB over USB. This step should be known to developer as it's a standard method to download/install any Android custom apk on phones/tablets.

==Experience Beaglebone as Android accessory==

After preparing the SD card for Beaglebone and installing apk on phone, please follow the steps below:

   * Insert the SD card into Beaglebone
   * Connect the power cable and power ON the board
   * Let the phone/tablet be in on state with accessory app running
   * Connect Beaglebone USB host port to mini/Micro-B USB port of the Android device (phone/tablet).
   * Control the LEDs on Beaglebone through the buttons displayed on the Android accessory UI on phone.
   * The phone displays a timer that is synced from RTC running on beaglebone.

This app is just an example to prove beaglebone communication with phone/tablet using Android accessory protocol. Both, the apk on phone and the application on beaglebone can be modified for any type of accessory. The Android accessory protocol need not be changed.


= Building Sources =

The procedure to download the sources, installing the toolchain and compiling the sources to generate the final images (like pre-built images) is described below

== Getting the Toolchain ==

   * Download CodeSourcery tool chain for ARM for Linux [http://www.codesourcery.com/sgpp/lite/arm/portal/package4465/public/arm-none-eabi/arm-2009q1-161-arm-none-eabi.bin LINK]

   * Install toolchain on Linux Host machine (ubuntu 10.04 or above)
{{{
   #> chmod 777 arm-2009q1-161-arm-none-eabi.bin
   #> ./arm-2009q1-161-arm-none-eabi.bin
}}}

   * Set PATH environment variable contain the path of the compiler/tool chain.

{{{
   Example:
   #> export PATH=$PATH:/opt/tools/CodeSourcery/Sourcery_G++_Lite/bin
}}}
   * Point LIB_PATH shell environment variable to the Code Sourcery installation

{{{
   Example:
   LIB_PATH=/opt/tools/CodeSourcery/Sourcery_G++_Lite
}}}

   Note: /opt/tools/ is the path selected while installing the toolchain. If you are installing toolchain path at some other location, please set PATH and LIB_PATH variable appropriately.
 
==Getting Source code==

As mentioned above, we use TI's StarterWare software package to develop Beaglbone Android accessory. 

   * Download StartWare Linux Installer package from [http://software-dl.ti.com/dsps/dsps_public_sw/am_bu/starterware/02_00_00_07/index_FDS.html HERE]
   * Install StarterWare package
{{{
   #> <path to package dir>/AM335X_StarterWare_02_00_00_07_Setup.bin
}}}
   * Download the Beaglebone Accessory patch to StarterWare [http://rowboat.googlecode.com/files/adk_patch.tar.gz from HERE]
   * Apply the patch
{{{ 
    #> cd <StarterWare 02.00.00.07>
    #> patch -p1< <patch to patch directory>/adk_patch/0001-Add-beaglebone-Accessory-support.patch
}}}

<br>

== Compile the Source Code ==

=== Building The Bootloader  ===

Use below commands to build the StarterWare bootloader, this will generate boot_ti.bin image at <Path to StarterWare code>/binary/armv7a/gcc/am335x/beaglebone/bootloader/Release

{{{    
   #> cd <Path to StarterWare Code>/build/armv7a/gcc/am335x/beaglebone/bootloader
   #> make

NOTE: Rename "boot_ti.bin" to MLO.

   #> mv <Path to StarterWare code>/binary/armv7a/gcc/am335x/beaglebone/bootloader/Release/boot_ti.bin <Path to StarterWare code>/binary/armv7a/gcc/am335x/beaglebone/bootloader/Release/MLO
}}}

== Building StarterWare Android Accessory Application  ==

Use below command to build the sample Beaglebone accessory application for StarterWare. This will generate an application usb_acc_ti.bin binary at <Path to StarterWare code>/binary/armv7a/gcc/am335x/beaglebone/usb_acc/Release/usb_acc_ti.bin

{{{
   #> cd <Path to StarterWare Code>/build/armv7a/gcc/am335x/beaglebone/usb_acc
   #> make

NOTE: Rename Application "usb_acc_ti.bin" to "app".

   #> mv <Path to StarterWare code>/binary/armv7a/gcc/am335x/beaglebone/usb_acc/Release/usb_acc_ti.bin <Path to StarterWare code>/binary/armv7a/gcc/am335x/beaglebone/usb_acc/Release/app
}}}

== Prepare the bootable SD/MMC card ==

Copy compiled images and mk-mmc-acc.sh script to image folder and populate SD/MMC card as follows.

{{{
   #> mkdir ~/image
   #> cd ~/image
   #> cp <Path to StarterWare code>/binary/armv7a/gcc/am335x/beaglebone/bootloader/Release/MLO .
   #> cp <Path to StarterWare code>/binary/armv7a/gcc/am335x/beaglebone/usb_acc/Release/app .
   #> cp <path to pre-built image>/BeagleBoneAcc/mkmmc-acc.sh .
   #> sudo ./mkmmc-acc.sh /dev/sd<device>
}}}

Above steps will create a bootable SD/MMC card which should be similar to pre-built images and can be used to bootup beaglebone.

Follow the steps mentioned above in the Out of the box demo section to boot the board and to use the beaglebone as an Android accessory.

= Customizing software to develop new accessory=

The Beaglebone accessory development kit makes a use of StarterWare USB stack and implements a USB accessory class driver which adhere to the Android opem accessory standard and accessory application to interact with the Android powered device. For detailed design of StarterWare USB stack, please visit http://processors.wiki.ti.com/index.php/StarterWare_USB#Core_Design 

Here is the block diagram of Beaglebone USB accssory software which highlights important software blocks. 
<br>
<br>
http://rowboat.googlecode.com/files/BB_accessory_stack.png 
<br>
<br>
== Host Controller driver  ==

The USB host controller driver handles all of the details necessary to discover and enumerate any USB device. The USB host controller driver only performs enumeration and relies on the host accessory class driver to perform any other communications with Android device. Most of the code used to enumerate devices is run in interrupt context and is contained in the enumeration handler. In order to complete the enumeration process, the host controller driver also requires that the application periodically call the USBHCDMain() function. 

The application has to register a USB accessory class with host controller driver using USBHCDRegisterDrivers() call so that enumeration events can be passed to it. 

Please refer to [http://processors.wiki.ti.com/index.php/StarterWare_USB StarterWare USB] documentation for more details about StarterWare USB. 

== USB Accessory Class Driver  ==

The USB Accessory class driver provides an interface to detect and set up communication with an Android accessory powered device. In general, an accessory class driver carries following steps. 

#Determine the device's accessory mode support 
#Attempt to start the device in accessory mode if needed 
#Establish communication with the device if it supports the Android accessory protocol 
#Provides accessory read and write APIs to communicate with Android accessory powered device.

Application has to call USBACCOpen() to register a callback. The Accessory class driver will call this registered callback to notify whether 

#USB Accessory device is connected 
#Unknown device is connected 
#Device is disconnected.

Once Device connected (USB_EVENT_CONNECTED) event is received, application the can read and write to accessory device using AccessoryRead() and AccessoryWrite() calls 

== Accessory Application  ==

Below block diagram demonstrate the Beaglebone accessory application code flow. 
<br> <br> 
http://rowboat.googlecode.com/files/BB_Accessory_Flow.png
 <br> <br> 

The application must register a USB accessory class driver by calling USBHCDRegisterDrivers() and call USBACCOpen to register a callback. The callback will get invoked by accessory class driver to indicate whether - <br> 

#Android accessory mode device is connected (USB_EVENT_CONNECTED)
#Unknown device is connected (UNKNOWN_DEVICE_EVENT) 
#Device is disconnected (USB_EVENT_DISCONNECTED).

Once the device connected event is received, accessory can communicate with the application running on Android powered device using custom communication protocol. 

The example application executes the following sequence: 

#Configure and enable the interrupts 
#Enable the USB clocking 
#Register the accessory host class driver 
#Open an instance of the accessory class driver 
#Initialize the power configuration 
#Initialize the host controller 
#Initializes user LED GPIO 
#Enables RTC 
#Periodically calls USBHCDMain() function to complete USB re-enumeration process 
#Sends RTC time data to Android Accessory powered device, receives LED control information and configure LEDs.

= How to Develop New Beaglebone Accessory  =

== Directory structure  ==

* Place application code in "&lt;path to StarterWare source&gt;/examples/beaglebone/&lt;your app folder name&gt;"

* Place your makefile and linker script in "&lt;path to StarterWare source&gt;/build/armv7a/gcc/am335x/beaglebone/&lt;your app folder name&gt;" directory. Follow below command to build your appliation
  $ cd <path to StarterWare source>/build/armv7a/gcc/am335x/beaglebone/<your app folder name>
  $ make
&nbsp;&nbsp;&nbsp; Note: You can take reference of makefile and linker script present in "&lt;path to StarterWare Source&gt;/build/armv7a/gcc/am335x/beaglebone/usb_acc" directory.
* Built binaries will be placed in folder "<path to StarterWare source>/binary/armv7a/gcc/am335x/beaglebone/<your app folder name> 

<br>

== Accessory Application Guidelines  ==

Following code snippet gives the rough idea on how to develop a new accessory application using StarterWare package. 

*Declare structure to use host accessory class driver

<font size="2"><code lang="c">
static tUSBHostClassDriver const * const g_ppHostClassDrivers[] =
{
  &g_USBACCClassDriver,
  &g_sUSBEventDriver
};
</code> </font> 

*Declare global variables to store accessory instance value and device connection state

<font size="2"><code lang="c">
static unsigned int g_ulACCInstance;
static unsigned int eUSBState;
</code> </font> 

*Implement a callback function so that application can be informed when an Android accessory powered device is connected and disconnected.

<font size="2"><code lang="c">

unsigned int ACCCallback(unsigned int ulEvent)
{
    switch(ulEvent)
    {
        case USB_EVENT_CONNECTED:
        {
          
            eUSBState = STATE_ACC_INIT;
            break;
        }

        case USB_EVENT_DISCONNECTED:
        {
            eUSBState = STATE_NO_DEVICE;
            break;
        }

        case UNKNOWN_DEVICE_EVENT:
        {
            eUSBState = STATE_UNKNOWN_DEVICE;
            break;
        }
    }
}
</code> </font> 

*Implement a main loop that runs the application

<font size="2"><code lang="c">
int main(void)
{
    MMUConfigAndEnable();

    /*configure arm interrupt controller to generate usb interrupt */
       
    /*Register the host class driver*/
    USBHCDRegisterDrivers(USB_INSTANCE, g_ppHostClassDrivers, 1);
   
    /* Open an instance of the accessory driver and register a callback*/
    g_ulACCInstance = USBACCOpen(USB_INSTANCE, ACCCallback);

    USBHCDPowerConfigInit(USB_INSTANCE, USBHCD_VBUS_AUTO_HIGH);

    /* Initialize the host controller stack */  
    USBHCDInit(USB_INSTANCE, g_pHCDPool, HCD_MEMORY_SIZE);
    USBHCDTimeOutHook(USB_INSTANCE, &USBHTimeOut);
    USBHTimeOut->Value.slNonEP0= 1;

    /*Do other necessary initialization specific to your application*/
    
    /* Call the main loop for the Host controller driver */
    USBHCDMain(USB_INSTANCE, g_ulACCInstance);
    
    /* Implement main loop for the application */
    while(1)
    {
       switch(eUSBState)
       {
           /* This state is entered when android accessory powered device is first detected */
            case STATE_ACC_INIT:
            {
                /* Do necessary initialization */            
                break;
            }
            case STATE_ACC_CONNECTED:
            {
                   /* Do accessory read and write operations.
                    * Implement your custom accessory communication protocol to 
                    * communicate with Android application
                    * running on Android accessory powered device.
                    */
                   break;
            }
            case STATE_NO_DEVICE:
            {
                 break;
            }
            default:
            {
                break;
            }
        }

        /* Periodically call the main loop for the Host controller driver */
        USBHCDMain(USB_INSTANCE, g_ulACCInstance);
    }
</code> </font>

=Android Accessory Development=

Please refer to [http://developer.android.com/guide/topics/connectivity/usb/accessory.html Google USB accessory API guide] and TI Accessory Demo Android application code to write your own accessory application.

=APPENDIX=

==Configuring Beaglebone to get serial console==

Serial console is provided via MiniB USB connection between the BeagleBone and the Host PC. The below instructions guides the user to download the necessary drivers and configure the host to get the console over USB<br> 

===For Windows===

'''Side note''': it may be possible to download [http://beagleboard.org/static/beaglebone/a3/Drivers/Windows/BONE_DRV.exe BONE_DRV.exe] for 32-bit Windows or [http://beagleboard.org/static/beaglebone/a3/Drivers/Windows/BONE_D64.exe BONE_D64.exe] for 64-bit Windows to avoid needing to manually edit the driver entries, but this has not yet been validated. 

For Windows XP, Download FTDI driver from http://www.ftdichip.com/Drivers/CDM/CDM20814_WHQL_Certified.zip 

Extract the contents and edit the ftdibus.inf file 

Replace the section between 

[FtdiHw] 

and 

[FtdiHw.NTamd64] 

with the following content 
<pre>%USB\VID_0403&amp;PID_A6D0.DeviceDesc%=FtdiBus.NT,USB\VID_0403&amp;PID_A6D0
%USB\VID_0403&amp;PID_A6D0&amp;MI_00.DeviceDesc%=FtdiBus.NT,USB\VID_0403&amp;PID_A6D0&amp;MI_00
%USB\VID_0403&amp;PID_A6D0&amp;MI_01.DeviceDesc%=FtdiBus.NT,USB\VID_0403&amp;PID_A6D0&amp;MI_01
%USB\VID_0403&amp;PID_A6D0&amp;MI_00.DeviceDesc%=FtdiBus.NT,USB\VID_0403&amp;PID_A6D0&amp;MI_00
%USB\VID_0403&amp;PID_A6D0&amp;MI_01.DeviceDesc%=FtdiBus.NT,USB\VID_0403&amp;PID_A6D0&amp;MI_01
%USB\VID_0403&amp;PID_A6D0&amp;MI_02.DeviceDesc%=FtdiBus.NT,USB\VID_0403&amp;PID_A6D0&amp;MI_02
%USB\VID_0403&amp;PID_A6D0&amp;MI_03.DeviceDesc%=FtdiBus.NT,USB\VID_0403&amp;PID_A6D0&amp;MI_03
%USB\VID_0403&amp;PID_A6D0.DeviceDesc%=FtdiBus.NT,USB\VID_0403&amp;PID_A6D0</pre> 
Also 

Replace the section between 

DriversDisk="FTDI USB Drivers Disk" 

and 

SvcDesc="USB Serial Converter Driver" 

with the following content 
<pre>USB\VID_0403&amp;PID_A6D0.DeviceDesc="USB Serial Converter"
USB\VID_0403&amp;PID_A6D0&amp;MI_00.DeviceDesc="USB Serial Converter A"
USB\VID_0403&amp;PID_A6D0&amp;MI_01.DeviceDesc="USB Serial Converter B"
USB\VID_0403&amp;PID_A6D0&amp;MI_00.DeviceDesc="USB Serial Converter A"
USB\VID_0403&amp;PID_A6D0&amp;MI_01.DeviceDesc="USB Serial Converter B"
USB\VID_0403&amp;PID_A6D0&amp;MI_02.DeviceDesc="USB Serial Converter C"
USB\VID_0403&amp;PID_A6D0&amp;MI_03.DeviceDesc="USB Serial Converter D"
USB\VID_0403&amp;PID_A6D0DeviceDesc="USB Serial Converter"
</pre> 
Then follow these steps 

*Boot the board 
*Connect Mini B USB cable between board and Windows PC. 
*If it is proceeding as planned, Windows will tell you it found a new hardware asks you to install the driver. Install driver that was downloaded as described in the above step 
*Answer "No, not this time" to the question about running Windows Update to search for software. 
*Choose "Install the hardware that I manually select from a list (Advanced)" this is the 2nd option, then click "Next" 
*Select "Show All Devices", then click "Next" 
*You are going to see a grayed-out text box with "(Retrieving a list of all devices)", click the "Have Disk..." button 
*Browse" to your driver folder (c:\...\_driver). It will be looking of a .inf file so select "ftdibus.inf" and click "Open" then "OK". 
*Select "USB Serial Port" then click the "Next" button. 
*A warning will appear, answer "Yes" but read the warning anyway. 
*Click the "Close" when the wizard is completed. 
*Disconnect and reconnect Mini B USB cable from Board(probably reboot it as well). 
*Serial COM port will be listed on the Terminal Utility menu 
*Adjust the baudrate to 115200 to connect to the BeagleBone serial.

==== In Linux  ====

To get serial console output on ubuntu follow these steps: 
<pre>$ sudo modprobe ftdi_sio vendor=0x0403 product=0xa6d0
$ minicom -D /dev/`dmesg | grep FTDI | grep "now attached to" | tail -n 1 | awk '{ print $NF }'` 
</pre> 
{{Note|
*You might need to make sure minicom's serial port setup is for 115200n8 with hardware flow control. You can get into the minicom configuration menu by invoking 'minicom -s' and selecting serial port setup -&gt; Serial Device (option A).
*You may have to run minicom with sudo in case sufficient permission is not available for the USB serial node
}}

=== Verifying Serial Connection<br>  ===

Once you finish setting up serial console, you can test the connection via the below steps 

*Push the small black reset button beside ethernet port 
*If your serial connection is proper, you can see the sequnce 'CCCC' getting popped up on the serial console.

== Powering on to Beaglebone Accessory  ==

Put the Micro SD card to the slot on the BeagleBone. Press the reset button again.
<br>
On Successful boot, following messages appear on the serial console.

    StarterWareAM335x Boot Loader
 Copying application image from MMC/SD card to RAM
 Jumping to StarterWare Application...
  .
  .
  .
After this the accessory application should take control and execute. <br>